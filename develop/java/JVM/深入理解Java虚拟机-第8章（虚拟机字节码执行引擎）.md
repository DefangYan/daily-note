## 第八章 虚拟机字节码执行引擎

### 8.1 运行时栈帧结构

1. 栈帧是用于支持虚拟机进行**方法调用**和**方法执行**的数据结构。
2. 栈帧是虚拟机运行时数据区中的**虚拟机栈**的栈元素。
3. 栈帧存储了**局部变量表**，**操作数栈**，**动态连接**和**方法返回地址**等信息。
4. 每一个方法从调用开始到执行完成，对应一个栈帧在虚拟机栈里**入栈到出栈**。
5. 在编译代码的时候，栈帧需要多大的局部变量表和多深的操作数栈都**已经完全确定**了，并写入**方法表的Code属性**中。所以栈帧需要分配多少内存，**不受程序运行期间变量影响**。
6. 一个线程中，方法调用链可能很长，有多个方法都处于执行状态（意味着虚拟机栈中有多个栈帧）。对于执行引擎来说，只有**栈顶的栈帧**是有效的，叫做**当前栈帧（Current Stack Frame）**，对应的方法叫**当前方法（Current Method）**。

#### 8.1.1 局部变量表

![栈帧的概念结构](https://images2015.cnblogs.com/blog/990532/201611/990532-20161113064456420-1511672121.jpg "栈帧的概念结构")

1. 用于存放**方法参数**和**方法内部定义**的**局部变量**。
2. Java程序被编译成class时，方法的**Code属性**的**max_locals数据**项中确定了该方法需要分配的**局部变量表最大容量**。
3. 局部变量表的容量以slot（也有叫word的）为单位。
4. boolean，byte，char，short，int，float，reference，returnAddress（因为占用大小一样，所以在这边介绍，但是应该不是在局部变量表中的）都是**一个单位**。
5. long，double是**两个单位**。占两个连续的slot空间，高位在前。
6. 虚拟机使用局部变量表完成参数值到参数变量列表的传递过程。
7. 如果这个方法是**实例方法（非static方法）**，局部变量表的**第0位索引**（内存中的第一个块），是一个对**堆当中的实例的引用**（代码中的`this`，就会用到这个引用）。
8. 局部变量表中的slot是**可重用的（内存可以重复使用）**，因为很多变量有自己的**作用范围**，超过范围之后就没用了，这块空间就可以留给后面的变量用了。
    
    举个例子，`if()`和`for()`中间的东西，只在两个{}之间有用，出了{}之后就没用了，这些内存就可以重复使用。
    
    还有一个例子
    ```
    public static void main(String[] args) {
        byte[] placeholder = new byte[64 * 1024 * 1024];
        System.gc();
    }
    ```
    这种情况下，placeholder对象的内存不会被回收。
    ```
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
    ```
    这种情况下，理论上应该被回收，但是也没有。
    ```
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        int[] a = 0;
        System.gc();
    }
    ```
    这种情况下，内存可以被回收。
    
    这是因为：
    1. 首先，这边的`System.gc()`回收的是**堆中**的placeholder对象。
    2. 判断是否要回收的标准是，**堆中**的placeholder对象是否有来自GC Roots的引用（有就不回收，没有就回收），在这里，局部变量表中的reference就是这个引用。
    3. 在第一个例子中，变量placeholder还**在作用域中**。所以局部变量表中还存在这个reference，所以placeholder对象不会被回收。
    4. 在第二个例子中，变量placeholder**不在作用域中了**。但是，之后**没有**对局部变量表的读写操作，所以局部变量表**没变**，局部变量表中还存在这个reference，所以placeholder对象不会被回收。
    5. 在第三个例子中，变量placeholder**不在作用域中了**。同时，`int[] a = 0;`这句代码，对局部变量表**实现了写操作**，由于局部变量表中的slot是**可重用**的，之前reference的那个slot就被`int[] a`占用了。失去了reference的引用之后，通过GC Roots就找不到placeholder对象了，于是GC的时候就把它回收了。
    > 通过虚拟机JIT编译器优化，并编译成本地代码之后，第二种情况好像也可以回收掉，不过这个例子用来学习原理还是很有意义的。
9. 局部变量表中的变量，跟类变量有一点区别。类变量会在准备阶段赋予默认值，局部变量表不会。
    ```
        public static void main(String[] args) {
            int a;
            System.out.println(a);
        }
    ```
    这段代码会报错，无法运行。

#### 8.1.2 操作数栈
#### 8.1.3 动态连接
#### 8.1.4 方法返回地址
#### 8.1.5 附加信息
### 8.2 方法调用
#### 8.2.1 解析
#### 8.2.2 分派
### 8.3 基于栈的字节码解释执行引擎
#### 8.3.1 解释执行
#### 8.3.2 基于栈的指令集与基于寄存器的指令集
#### 8.3.3 基于栈的解释器执行过程