## 第三章 垃圾收集器与内存分配策略

目前的内存分配和回收技术已经很成熟，但是当内存溢出，内存泄漏，或者垃圾收集成为系统达到**更高并发量**的瓶颈时，还需要关注内存分配和垃圾回收。

程序计数器，虚拟机栈，本地方法栈，这几个区域的内存的分配和回收，都具备确定性，所以不用过多考虑内存回收问题。
1. **分配多少内存在类的结构中已经确定了**。
2. **方法结束的时候内存跟着就回收了**。

Java堆和方法区不一样。
1. **一个接口的多个实现类需要的内存可能不一样**。
2. **一个方法的多个分支需要的内存也不一样**。
3. **一个对象实例可能被多个方法引用，所以回收的时间也不是确定的**。

### 3.1 对象已死？

垃圾回收的基础，是确定对象实例是否还活着（不再被任何人引用，就说明已经死去）

#### 3.1.1 引用计数算法

在对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器的值就+1，当引用失效时，计数器的值就-1。当**计数器为0**时，这个对象就是**不再被使用的对象**。

这种方法最大的问题是，它很难解决**对象之间的互相循环引用**的问题。下面的代码就是一个循环引用的例子。

    public class ReferenceCountingGC {
    
        public Object instance = null;
    
        private static final int _1MB = 1024 * 1024;
    
        /**
         * 这个成员属性的意义时占用一点内存，便于在GC日志中清晰的看出内存是否被回收
         */
        private byte[] bigSize = new byte[2 * _1MB];
    
        public static void main(String[] args) {
            ReferenceCountingGC objA = new ReferenceCountingGC();
            ReferenceCountingGC objB = new ReferenceCountingGC();
            objA.instance = objB;
            objB.instance = objA;
    
            objA = null;
            objB = null;
    
            // 假设在这里发生GC，那么objA和objB能否被回收
            System.gc();
        }
    
    }

上面的代码中，objA和objB**互相引用对方**，导致它们的**引用计数器都不是0**，但实际上这两个对象已经没用了。如果GC收集器判断对象实例是否死亡的依据是引用计数器的话，`System.gc()`的时候，内存就不会被回收。但是实际上内存却被回收了，说明**Java虚拟机不使用计数器算法来判断对象实例是否存活**。

#### 3.1.2 根搜索算法（GC Roots Tracing）

通过一些**“GC Roots”对象作为起始点**，向下搜索，搜索所走过的路径（称为引用链），当一个对象**到GC Roots没有任何引用链相连**（简单说就是从GC Roots到这个对象不可达）时，则证明这个**对象不可用**。

Java中可作为GC Roots的对象有一下几种：
1. **虚拟机栈中**（栈帧中的本地变量表）的引用的对象。
2. **方法区中的类静态属性**引用的对象。
3. **方法区中的常量**引用的对象。
4. **本地方法中**JNI（native方法）的引用的对象。

[](https://img-blog.csdn.net/20171129142211991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4NjY4MDg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

如图所示，Object5，6，7虽然不像关联，但是它们是GC Roots不可达的，所以是可回收的对象

#### 3.1.3 再谈引用

1. 不论引用计数算法，还是根搜索算法，判定标准都与**引用**有关。
2. 最早的时候，Java堆引用的定义很传统：如果reference类型的数据中存储的数值是**代表另一块内存的起始地址**，那么就称**这块内存代表一个引用**。
3. 设计者认为，在内存足够的时候，可以存在一些缓存，所以jdk1.2之后的版本，引用类型有四种：强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference），虚引用（Phantom Reference）。
    1. **强引用**：Java中普遍存在的类似`Object obj = new Object()`这类引用就是强引用。强引用**只要还存在，垃圾回收器永远不会回收**被引用对象。
    2. **软引用**：在jdk1.2之后，提供了**SoftReference**类来实现软引用。软引用描述一些**还有用，但不是必须**的对象。在系统**内存要溢出之前**，才会回收软引用。
    3. **弱引用**：在jdk1.2之后，提供了**WeakReference**类来实现弱引用。弱引用比软引用更弱，弱引用关联的对象，**只能生存到下次垃圾回收之前**，只要发生垃圾回收，不论内存够不够，弱引用的关联的对象都会被回收掉。
    4. **虚引用**：在jdk1.2之后，提供了**PhantomReference**类来实现虚引用。需引用**完全不会对其生存时间构成影响**，也**无法通过虚引用来取得一个对象实例**。设置虚引用的目的是，希望能在这个**对象被收集时收到一个系统通知**。

#### 3.1.4 生存还是死亡？

1. 根搜索算法中不可达的对象，也不是立马被回收，一个对象被回收，需要**经历两次标记过程**。
    1. 如果对象被发现，没有与GC Roots相连的引用链，它会被**第一次标记**，并进行**一次筛选（筛选的条件是，这个对象是否有必要执行finalize()方法）**。
        * 如果对象**没有覆盖finalize()方法**，或者finalize()方法**已经被虚拟机调用过**，那么虚拟机认为**没必要执行finalize()方法**了（**这个对象就没机会了**）。
        * 如果虚拟机认为有必要执行finalize()方法，这个对象会被放到一个叫**F-Queue的队列**中，稍后由一个**低优先级的Finalizer线程**执行。
            > 这个方法会被出发，但并不一定会结束，因为如果这个对象的finalize()方法**特别慢或者死循环**，后面的其他对象都得等着，系统可能会崩溃。
    2. 如果对象在finalize()方法中把自己的值赋给了其他猴哥变量，那么它就不会被第二次标记，否则就会被**第二次标记**（离死不远了）。
    
下面是一段示例代码：
    
    public class FinalizeEscapeGC {
    
        private static FinalizeEscapeGC SAVE_HOOK = null;
    
        private void isAlive() {
            System.out.println("yes, I am still alive.");
        }
    
        protected void finalize() throws Throwable {
            super.finalize();
            System.out.println("finalize method executed");
            FinalizeEscapeGC.SAVE_HOOK = this;
        }
    
        public static void main(String[] args) throws Throwable {
            SAVE_HOOK = new FinalizeEscapeGC();
    
            // 对象第一次成功拯救自己
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法的优先级比较低，所以暂停0.5秒，登登它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, I am dead.");
            }
    
            // 下面这段代码完全相同，但是这次自救却失败了，因为finalize()方法只会被调用一次
            SAVE_HOOK = null;
            System.gc();
            // 因为Finalizer方法的优先级比较低，所以暂停0.5秒，登登它
            Thread.sleep(500);
            if (SAVE_HOOK != null) {
                SAVE_HOOK.isAlive();
            } else {
                System.out.println("no, I am dead.");
            }
        }
    }

运行结果：

    finalize method executed
    yes, I am still alive.
    no, I am dead.
    
1. 示例代码中可以看到，finalize()方法被触发了，对象在被回收前被拯救了。
2. 上面相同的代码重复了两遍，第一遍成功了，第二次失败。因为finalize()方法**只会被自动调用一次**，上面说到过“如果finalize()方法已经被虚拟机调用过，虚拟机认为没必要执行finalize()方法了”，只有没被调用过的，才会被调用。
3. **但是这个功能，不是很推荐使用，代价比较高，不确定性太大。**

#### 3.1.5 回收方法区

1. 虚拟机规范说过“**不要虚拟机在方法区实现垃圾回收**”。
2. 堆中垃圾回收**性价比高**（新生代可以回收70% - 95%的空间），方法区（1.8之前是永久带）**回收效率很低**。
3. 永久带的垃圾收集主要分两部分：**废弃常量**和**无用的类**。
    1. 回收常量与堆种回收对象**非常相似**。假如一个字符串“abc”进入了常量池，但是当前系统没有任何一个String对象也是“abc”，说明**没有其他地方引用**了这个字面量。如果这时候发生内存回收，必要时常量“abc”会被回收掉。常量池中的**其他类（接口）**，**方法**，**字段**的符号引用也类似
    2. 判断**废弃常量**很简单，判断无用的类比较复杂，需要满足如下3个条件。满足条件的无用类**可以被回收，但不是必须**。
        1. 该类的**所有实例**都已经被回收，Java堆中不存在该类的任何实例。
        2. 加载该类的ClassLoader已经被回收。
        3. 该类对应的java.lang.Class对象**没有在任何地方被引用**，无法在任何地方**通过反射**访问该类的方法。

### 3.2 垃圾收集算法

由于垃圾回收算法的实现涉及大量细节，而且各个平台虚拟机操作内存的方式都不一样，这边不讨论实现，只介绍思想。

#### 3.2.1 标记-清除算法（Mark-Sweep）

[标记清除](https://camo.githubusercontent.com/2300ad44e7d31e4165c1ceffe3bad183e921a512/68747470733a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f616e64792d7a686f752f3830363433352f6f5f4a766d5f54756e696e673030322e706e67 "标记清除")

1. 算法分为**标记**和**清除**两个阶段。
    1. **标记出所有**需要回收的对象。
    2. 标记完成之后，**统一回收**所有被标记对象。
2. 主要有两个**缺点**：
    1. 效率问题：标记和清除过程，**效率都不高**。
    2. 空间问题：标记清除之后，会产生大量不连续的**内存碎片**，碎片过多有可能会造成**大对象无法分配**，不得不**提前**回收垃圾。

#### 3.2.2 复制算法（Copying）

[复制算法](https://camo.githubusercontent.com/743c588417699bd97b9653055fe9e5966d8c2f5f/68747470733a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f616e64792d7a686f752f3830363433352f6f5f4a766d5f54756e696e673030332e706e67 "复制算法")

1. 算法将内存分成两块，每次**只用其中一块**。
2. 当这块内存满了，就把**还存活**的对象复制到另一块上面，然后把已经使用过的内存空间**一次性清理掉**。
3. **优点**：实现简单，运行高效，**不考虑碎片**问题。
4. **缺点**：
    1. 只有一半的内存可以使用。
    2. 在对象**存活率比较高**的时候，需要执行**太多的复制**操作，效率会降低。
5. 大多数虚拟机用这种算法来回收**新生代**。

#### 3.2.3 标记-整理算法（Mark-Compact）

[标记整理](https://camo.githubusercontent.com/1c5631e5e7fc857655d07a98f228d92f2fe16ca5/68747470733a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f616e64792d7a686f752f3830363433352f6f5f4a766d5f54756e696e673030342e706e67 "标记整理")

1. 算法分为**标记**和**整理**两个阶段。
    1. 标记阶段跟**标记清除**算法一样。
    2. 不直接清理可回收对象，而是让所有存活对象**向一端移动**，然后**清理边界以外的内存**。
2. **优点**：
    1. 避免了**标记清除**算法的**碎片**问题
    2. 避免了**复制**算法的**空间**问题

#### 3.2.4 分代收集算法

### 3.3 垃圾收集器

#### 3.3.1 Serial收集器
#### 3.3.2 ParNew收集器
#### 3.3.3 Parallel Scavenge收集器
#### 3.3.4 serial Old收集器
#### 3.3.5 Parallel Old收集器
#### 3.3.6 GMS收集器
#### 3.3.7 G1收集器
#### 3.3.8 垃圾收集器参数总结

### 3.4 内存分配与回收策略

#### 3.4.1 对象优先在Eden分配
#### 3.4.2 大对象直接进入老年代
#### 3.4.3 长期存活的对象将进入老年代
#### 3.4.4 动态对象年领判定
#### 3.4.5 空间分配担保