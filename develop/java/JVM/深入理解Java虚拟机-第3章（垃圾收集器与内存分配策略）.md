## 第三章 垃圾收集器与内存分配策略

目前的内存分配和回收技术已经很成熟，但是当内存溢出，内存泄漏，或者垃圾收集成为系统达到**更高并发量**的瓶颈时，还需要关注内存分配和垃圾回收。

程序计数器，虚拟机栈，本地方法栈，这几个区域的内存的分配和回收，都具备确定性，所以不用过多考虑内存回收问题。
1. **分配多少内存在类的结构中已经确定了**。
2. **方法结束的时候内存跟着就回收了**。

Java堆和方法区不一样。
1. **一个接口的多个实现类需要的内存可能不一样**。
2. **一个方法的多个分支需要的内存也不一样**。
3. **一个对象实例可能被多个方法引用，所以回收的时间也不是确定的**。

### 3.1 对象已死？

垃圾回收的基础，是确定对象实例是否还活着（不再被任何人引用，就说明已经死去）

#### 3.1.1 引用计数算法

在对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器的值就+1，当引用失效时，计数器的值就-1。当**计数器为0**时，这个对象就是**不再被使用的对象**。

这种方法最大的问题是，它很难解决**对象之间的互相循环引用**的问题。下面的代码就是一个循环引用的例子。

    public class ReferenceCountingGC {
    
        public Object instance = null;
    
        private static final int _1MB = 1024 * 1024;
    
        /**
         * 这个成员属性的意义时占用一点内存，便于在GC日志中清晰的看出内存是否被回收
         */
        private byte[] bigSize = new byte[2 * _1MB];
    
        public static void main(String[] args) {
            ReferenceCountingGC objA = new ReferenceCountingGC();
            ReferenceCountingGC objB = new ReferenceCountingGC();
            objA.instance = objB;
            objB.instance = objA;
    
            objA = null;
            objB = null;
    
            // 假设在这里发生GC，那么objA和objB能否被回收
            System.gc();
        }
    
    }

上面的代码中，objA和objB**互相引用对方**，导致它们的**引用计数器都不是0**，但实际上这两个对象已经没用了。如果GC收集器判断对象实例是否死亡的依据是引用计数器的话，`System.gc()`的时候，内存就不会被回收。但是实际上内存却被回收了，说明**Java虚拟机不使用计数器算法来判断对象实例是否存活**。

#### 3.1.2 根搜索算法（GC Roots Tracing）

通过一些“GC Roots”对象作为起始点，向下搜索，搜索所走过的路径（称为引用链），当一个对象到GC Roots没有任何引用链相连（简单说就是从GC Roots到这个对象不可达）时，则整明这个对象不可用






#### 3.1.3 再谈引用
#### 3.1.4 生存还是死亡？
#### 3.1.5 回收方法区

### 3.2 垃圾收集算法

#### 3.2.1 标记-清楚算法
#### 3.2.2 复制算法
#### 3.2.3 标记-整理算法
#### 3.2.4 分代收集算法

### 3.3 垃圾收集器

#### 3.3.1 Serial收集器
#### 3.3.2 ParNew收集器
#### 3.3.3 Parallel Scavenge收集器
#### 3.3.4 Serial Old收集器
#### 3.3.5 Parallel Old收集器
#### 3.3.6 GMS收集器
#### 3.3.7 G1收集器
#### 3.3.8 垃圾收集器参数总结

### 3.4 内存分配与回收策略

#### 3.4.1 对象优先在Eden分配
#### 3.4.2 大对象直接进入老年代
#### 3.4.3 长期存活的对象将进入老年代
#### 3.4.4 动态对象年领判定
#### 3.4.5 空间分配担保