## 第二章 Java内存区域与内存溢出异常

### 2.1 运行时数据区域

Java虚拟机会把运行过程中的内存分为几个不同的数据区。每个区域用途不统，创建和销毁的时间不统。主要包括一下几个数据区。

![Java运行时数据区](https://ws1.sinaimg.cn/large/006tNc79ly1fmk5v19cmvj30g20anq3y.jpg "Java运行时数据区")

#### 2.1.1 程序计数器（Program Counter Register）

1. 程序计数器主要用来记录当前线程所执行的字节码的行号。Java虚拟机通过改变计数器的值来选取下一条要被执行的字节码指令。
2. 程序计数器是为**线程私有**的。为了能使多线程环境下，线程切换之后，每个线程都能恢复到正确的执行位置。
3. 如果线程在执行Java方法，计数器记录的是字节码行数，如果执行native方法，计数器的值是Undefined。这个内存区域是**唯一一个没有OutOfMemoryError的情况**的区域。

#### 2.1.2 Java虚拟机栈（Java Virtual Machine Stacks）

1. 与程序计数器一样，Java虚拟机栈也是**线程私有**的。
2. 每个方法被执行的时候，都会创建一个栈帧（Stack Frame），用于存储**局部变量表**，**操作数栈**，**动态链接**，**方法出口**等信息。
3. 局部变量表
    1. 存放了 - 编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）
    2. 存放了 - 对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
    3. 存放了 - returnAddress类型（指向了一条字节码指令的地址）。
    4. 局部变量表中的64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。
    5. 局部变量表所需的内存空间**在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间**不会改变**局部变量表的大小。
4. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常
5. 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出**OutOfMemoryError**异常。

#### 2.1.3 本地方法栈（Native Method Stack）

1. 本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
2. 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。
3. 与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

#### 2.1.4 Java堆



#### 2.1.5 方法区

#### 2.1.6 运行时常量池

#### 2.1.7 直接内存


### 2.2 对象访问




### 2.3 实战：OutOfMemoryError