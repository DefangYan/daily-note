## 第十二章 线程安全与锁优化

### 13.1 线程安全

1. 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。
2. 大多数场景中，会弱化这个定义，把“调用这个对象的行为”限定为“单次调用”。

#### 13.1.1 Java语言中的线程安全

##### 13.1.1.1 不可变

1. 在Java语言里（jdk1.5之后，即Java内存模型被修正之后），**不可变的对象，一定是线程安全的**。
2. 如果共享对象是一个**基本数据类型**，那么只要在**定义的时候使用final关键字**修饰它就可以保证它是不可变的。
3. 如果共享对象是一个**对象**，那么就需要**保证对象的行为不会对其状态产生任何影响**，才能保证它是不可变的。
    >例如java.lang.String，它是一个典型的不可变对象，我们调用它的substring()，replace()和concat()这些方法，都不会影响它原本的值，只会返回一个新构造的字符串对象。
4. 保证对象行为不影响自己状态的途径有很多，最简单的是，把对象中**带状态的变量都声明为final**，这样在构造结束只会，它就是不可变的。
    ```text
    private final int value;
    
    public Integer(int value) {
        this.value = value;
    }
    ```
    例如上面的代码，取自java.lang.Integer，它通过将内部状态变量value定义为final，来保证状态不变。

##### 13.1.1.2 绝对线程安全

1. 绝对的线程安全完全满足13.1中第一条的定义，“绝对”两个字，非常安格。
    >书上用Vector的例子说明了，不加synchronized的时候，会出问题，但是我亲测没有实现。

##### 13.1.1.3 相对线程安全

1. 相对的线程安全就是我们通常意义上讲的线程安全。它需要保证**对这个对象单独的操作是线程安全**的，我们在调用的时候不需要做额外的保障措施。
    >但是对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步手段来保证调用的正确性。
2. Java语言中，大部分线程安全都是相对线程安全，例如Vector，HashTable，Collections的synchronizedCollection()方法包装的集合等。

##### 13.1.1.4 线程兼容

1. 线程兼容是指，**对象本身并不是线程安全的**，但是**可以通过在调用端正确地使用同步手段**来保证对象在开发环境中安全地使用。
2. 平常说一个类**不是线程安全的**，大多是这种情况。
3. ArrayList和HashMap等。

##### 13.1.1.5 线程对立

1. 不管调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

#### 13.1.2 线程安全的实现方法

##### 13.1.2.1 互斥同步（Mutual Exclusion & Synchronization）

1. 互斥同步是最常见的一种**并发正确性保障手段**。
    1. **同步**时指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。
    2. **互斥**时实现同步的一种手段，临界区（Critical Section），互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。
2. 最基本的互斥同步手段就是**synchronized关键字**。
    1. synchronized关键字经过编译之后，会在同步块前后分别形成`monitorenter`和`monitorexit`这两个字节码指令。
    2. `monitorenter`和`monitorexit`这两个字节码都需要一个**reference类型的参数**，来指明锁定和解锁的对象。
    3. 如果没有指定参数，那么就根据synchronized修饰的实例方法还是类方法，去获取对应对象实例或者Class对象来作为锁对象。
    4. 执行`monitorenter`指令时，首先要获取对象的锁。如果对象没被锁定，或者当前线程已经拥有对象的锁，那么把锁的计数器加1.
    5. 执行`monitorexit`指令时，会将计数器减1，当计数器是0的时候，锁就被释放了。
3. 

##### 13.1.2.2 非阻塞同步
##### 13.1.2.3 无同步方案
### 13.2 锁优化
#### 13.2.1 自旋锁与自适应自旋
#### 13.2.2 锁消除
#### 13.2.3 锁粗化
#### 13.2.4 轻量级锁
#### 13.2.4 偏向锁