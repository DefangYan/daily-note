## 第十二章 Java内存模型与线程

1. 多任务原因：
    1. 计算机速度比通讯和存储快太多，大多数时间都花在磁盘IO，网络通讯和数据库访问，为了避免处理器大多数时间处于等待。
    2. 一个服务器对应多个客户端，需要多任务。
2. 每秒事务处理数（Transactions Per Second，TPS）是最重要的指标之一。

### 12.1 硬件的效率与一致性

1. 读写内存太慢了，所以需要**高速缓存**。
2. 缓存的使用：
    1. 将需要的数据复制到缓存中，让运算能快速进行，当运算结束后，再**从缓存同步**回内存中。
3. 缓存的**问题**：
    ![处理器，高速缓存，主内存交互](https://img-blog.csdn.net/20151107223057063 "处理器，高速缓存，主内存交互")
    1. **缓存一致性（Cache Coherence）**：多处理器系统中，每个处理器都有自己的高速缓存，同时共享同一主内存。当多个处理器运算涉及同一块内存时，可能导致各自的缓存数据不一致，那么同步到主内存时，以谁的缓存数据为准呢？
    2. 为了解决这个问题，在读写时要根据**协议**来操作（Java虚拟机可以借鉴这种方式），例如MSI，MESI，MOSI，Synapse，Firefly及Dragon Protocol等等。
4. 处理器还会对输入代码进行**乱序执行优化（Out-Of-Order Execution）**，Java虚拟机的即时编译器中也有类似的**指令重排序（Instruction Reorder）优化**。

### 12.2 Java内存模型

1. Java规范定义了一种Java内存模型（Java Memory Model，JMM）来屏蔽各种硬件和操作系统的访问差异。
    >在此之前，C和C++之类的语言直接使用物理硬件（或者说操作系统的内存模型），所以在不同平台上会有差异，导致不可用。

#### 12.2.1 主内存与工作内存

1. Java内存模型规定了所有的**变量**都存储在**主内存**中。
    1. 这个变量，包括实例字段，静态字段，等共享变量（不包括线程私有的局部变量和方法参数）。
    2. 这个主内存，时虚拟机内存中的主内存（不是计算机中的主内存）。
2. 每个线程都有自己的私有的**工作内存**。
    1. 工作内存中保存了被该线程使用到的变量的主内存**副本拷贝**，线程对变量的操作（读取，写入）都必须在工作内存中进行，而**不能直接读写**主内存中的变量。
    2. 不同线程无法直接访问对方工作内存中的变量，线程间变量值传递通过主内存完成。
    ![主内存与工作内存](https://images2015.cnblogs.com/blog/724399/201703/724399-20170302101629751-1617442155.png)
    3. 这里的主内存，工作内存，与堆，栈，方法区等，不是同一种划分规则。
        
        如果一定要对应起来，那从变量，主内存，工作内存的定义来看。主内存主要对应Java堆中对象的**实例数据部分**，而工作内存则对应**虚拟机栈中的部分区域**。
        
        从更低的层次来说，主内存就是**硬件的内存**。而为了获取更快的运行速度，工作内存可能回优先存储于**寄存器和高速缓存**中。

#### 12.2.2 内存间交互操作

1. 主内存与工作内存之间具体的交互协议（即变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存），Java内存模型中定义了以下8种操作：
    1. **lock（锁定）**：作用于**主内存**的变量，把一个变量标识为一条线程**独占**的状态。
    2. **unlock（解锁）**：作用于**主内存**的变量，把一个**处于锁定**状态的变量**释放**出来，释放之后的变量才能被其他线程锁定。
    3. **read（读取）**：作用于**主内存**的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
    4. **load（载入）**：作用于**工作内存**的变量，把read操作从主内存中得到的变量值放入工作内存的**变量副本**中。
    5. **use（使用）**：作用于**工作内存**的变量，把工作内存中的一个变量**传递给执行引擎**，每当虚拟机遇到一个需要使用到**变量的值**的字节码指令时会执行这个操作。
    6. **assign（赋值）**：作用于**工作内存**的变量，把一个从执行引擎**接收到的值赋值**给工作内存的变量，每当虚拟机遇到一个**给变量赋值**的字节码指令时执行这个操作。
    7. **store（存储）**：作用于**工作内存**的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用。
    8. **write（写入）**：作用于**主内存**的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。
2. Java内存模型规定了执行上述操作时**必须满足**如下规则：
    1. 如果要把变量从主内存读取到工作内存，必须顺序执行read、load。如果要将变量从工作内存同步回主内存，必须顺序执行store、write。**只需要顺序，不需要连续**，可以试read a，read b，load a，load b。
    2. **不允许**read和load，store和write操作之一**单独出现**。
    3. **不允许**一个线程**丢弃**它的最近的**assign操作**（变量在内存中改变了之后，**必须同步**回主内存）。
    4. **不允许**一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
    5. 一个新的变量**只能**才主内存中“诞生”，**不允许**在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，use前面必须有load，store前面必须有assign。
        >~~这里的assign和初始化，网上的贴子和文章有出入~~
    6. 一个变量，同一时刻，**只能被一条线程**对其进行lock操作，可以**多次**lock，但是对应也要有**多次unlock才能解锁**。
    7. 如果对一个变量执行**lock操作**，会**清空**工作内存中此变量的值，在执行引擎使用这个变量前，需要**重新执行**read和load操作初始化变量的值。
        >~~这里的assign和初始化，网上的贴子和文章有出入~~
    8. **没被lock**的变量无法被unlock。无法unlock一个被其他线程lock的变量。
    9. 对一个变量**执行unlock操作之前**，**必须**先把变量**同步**回主内存中（执行store和write）。

#### 12.2.3 对volatile型变量的特殊规则

1. **volatile**是Java虚拟机提供的**最轻量级**的**同步机制**。
2. 变量被定义成volatile之后，具备两种特性：
    1. 保证变量对所有的线程的**可见性**。这里的可见性是指，当一个线程修改了这个变量的值，**新值**对于其他线程来说是可以**立即得知**的。
        >举个不同变量的例子：线程A修改了普通变量a，然后向主内存进行回写。线程B在线程A回写**完成之后**再从主内存读取变量a，a的值才会对线程B可见，否则不可见。
        
        这里存在一个误区，volatile变量在各个线程中**是一致的**，但是**并不是并发安全的**。
        
        volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中的volatile变量也可以存在不一致的情况，但是每次**使用前都要刷新**，所以执行引擎看不到不一致的情况，所以可以认为是一致的），但是Java里面的**运算并非原子操作**，导致volatile变量的运算在并发下一样是不安全的，下面是示例代码：
        ```java
        /**
         * volatile变量自增运算测试
         */
        public class VolatileTest {
        
            public static volatile int race = 0;
        
            public static void increase() {
                race++;
            }
        
            private static final int THREADS_COUNT = 20;
        
            public static void main(String[] args) {
                Thread[] threads = new Thread[THREADS_COUNT];
                for (int i = 0; i < THREADS_COUNT; i++) {
                    threads[i] = new Thread(new Runnable() {
        
                        @Override
                        public void run() {
                            for (int j = 0; j < 10000; j++) {
                                increase();
                            }
                        }
                    });
                    threads[i].start();
                }
                // 等待所有累加线程都结束
                while (Thread.activeCount() > 1) {
                    Thread.yield();
                }
                System.out.println(race);
            }
        }
        ```
        这段代码发起了20个线程，每个线程对race进行10000次自增，如果能正确并发，输出应该是200000，但是这个代码每次结果都不一样，不会输出200000。
        
        问题出在race++之中，我们用javap反编译这段代码之后，获取如下字节码。
        ```text
        public static void increase();
          Code:
           Stack=2, Locals=0, Args_size=0
           0:   getstatic       #13; //Field race:I
           3:   iconst_1
           4:   iadd
           5:   putstatic       #13; //Field race:I
           8:   return
          LineNumberTable:
           line 14: 0
           line 15: 8
        ```
        从上面的字节码很容易就分析出：当`getstatic`指令把race的值取到操作数栈顶时，volatile关键字保证了race的值是正确的，但是执行`iconst_1`和`iadd`这些指令的时候，其他线程可能已经把race的值变大了，而在操作数栈顶的数据就成了过期数据，所以`putstatic`就会把较小的race值同步回主内存。
        
        其实这个地方就算只有一个操作（一个操作也可能有好多个步骤），也不一定能保证原子性，所以volatile关键字就无法保证并发安全，仍然需要通过加锁（synchronized或JUC包中的原子类）来保证原子性。
        
        像下面这种情况，就很适合使用volatile变量来控制并发。
        ```text
        volatile boolean shutdownRequested;

        public void shutdown() {
           shutdownRequested = true;
        }

       public void doWork() {
           while (!shutdownRequested) {
               // do anything     
           }
       }
        ```
    2. volatile变量的第二个语义是**禁止指令重排序优化**（对应12.1中的第4条）。
    
        下面是一个例子：
        ```text
        int a=10 ;//1
        int b=20 ;//2
        int c= a+b ;//3
        ```
        在Java中，普通变量仅仅会保证在这个方法的执行过程中，所有依赖赋值结果的地方，都能**获取正确的结果**，但是不能保证变量赋值操作的顺序与代码中的**执行顺序一致**。就像上面这个例子，一段特别简单的代码，理想情况下它的执行顺序是：1>2>3。但**有可能**经过JVM优化之后的执行顺序变为了 2>1>3。
        ```text
        private static Map<String,String> value ;
        private static volatile boolean flag = false ;
        
        //以下方法发生在线程 A 中 初始化 Map
        public void initMap(){
            //耗时操作
            value = getMapValue() ;//1
            flag = true ;//2
        }
        
        
        //发生在线程 B中 等到 Map 初始化成功进行其他操作
        public void doSomeThing(){
            while(!flag){
                sleep() ;
            }
            //do something
            doSomeThing(value);
        }
        ```
        假如上面的flag**没有**被volatile修饰，JVM可能会对1和2进行**重排**，导致value都还没有被初始化就有可能被线程B使用了。
        
        所以加上volatile之后可以**防止这样的重排优化，保证业务的正确性**。
3. 大多数场景下，volatile同步机制的性能要优于锁（synchronized和JUC包里的锁），是否选择volatile的依据是，**volatile的语义能否满足使用场景要求**。
    1. volatile**读**操作跟**普通变量**几乎没有区别。
    2. volatile**写**操作可能会慢上一些，因为它需要在本地代码中插入许多内存屏障（Memory Barrier或Memory Fence）指令来保证处理器**不发生乱序执行**。
4. **volatile**总结：
    
    假设T表示一个线程，V和W分别表示两个volatile变量，那么在进行read，load，use，assign，store和write操作时，需要满足如下规则：
    1. **一致性方面**：load之后才能use。只有在想要use的时候，才能load（想要load，目的必须是use）。所以线程T对变量V的use动作，可以认为是与load和read动作相关联的，**必须一起连续出现**（这个规则要求，在工作内存中，每次使用变量V之前，都**必须从主内存刷新最新的值**，用于保证自己能看到其他线程对变量V所作的修改（**保证一致性**））。
    2. **一致性方面**：assign之后才能store。只有在想要store的时候，才能assign（想要assign，目的必须是store）。线程T对变量V的assign动作，可以认为是与store和write动作相关联的，**必须一起连续出现**（这个规则要求，在工作内存中，每次修改变量V之后，都**必须立刻同步回主内存中**，用于保证其他线程可以看到自己对变量V所作的修改（**保证一致性**））。
    3. **禁止指令重排方面**：假设线程T对变量V有动作use_v，load_v和read_v（也可以是assign，store和write），对变量W有动作use_w，load_w和read_w。如果use_v优先于use_w，那么read_v也优先于read_w（这个规则要求，volatile修饰的变量**不会被指令重排**，保证代码的执行顺序与程序相同）。

#### 12.2.4 对于long和double型变量的特殊规则

1. Java内存模型要求lock，unlock，read，load，assign，use，store和write这八个操作都具有原子性。
2. 但是对于64位的数据类型（long和double），允许将没有被volatile修饰的数据的读写操作划分为两次32位操作来进行，不过虚拟机一般还是会实现原子性。

#### 12.2.5 原子性，可见性与有序性

##### 12.2.5.1 原子性（Atomicity）

1. Java的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。
2. 由Java内存模型直接保证的原子性变量操作包括**read，load，use，assign，store，write**这六个。大致可以认为，基本数据类型的访问读写是具备原子性的。
3. 如果应用场景需要更大范围的原子性，Java内存模型还提供了**lock和unlock**。不过用户无法直接调用lock和unlock，用户只能使用`monitorenter`和`monitorexit`，这两个字节码指令反映到Java代码中就是`synchronized`关键字，所以`synchronized`块之间的操作**具备原子性**。

##### 12.2.5.2 可见性（Visibility）

1. 可见性就是指，当一个线程**修改了共享变量**的值，其他线程能够**立即得知**这个修改。
2. Java内存模型通过变量修改后**将新值同步回主内存**，在变量读取前**从主内存刷新变量值**这种依赖主内存为传递媒介的方式来实现可见性的。
    >volatile变量的特殊规则，保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新。
3. 除了**volatile**之外，还有两个关键字可以实现可见性，它们是**final**和**synchronized**。
    1. synchronized的可见性是由“对一个变量执行**unlock**（没有unlock的变量，其他线程访问不到）操作之前，**必须**先把变量**同步回主内存**中（执行store和write操作）”这条规则获得的。
    2. final应该就是说不可变，所以每个线程看到都一样吧。（原文里说了什么，构造器初始化完成，并且没有把“this”的引用传递出去，不太明白）

##### 12.2.5.3 有序性（Ordering）

1. Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的，如果在另一个线程观察这个线程，所有操作都是无序的。
    1. 前半句是指，线程内表现为串行的语义
    2. 后半句是指，指令重排序，和，工作内存与主内存同步延迟。
2. Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的**有序性**。
    1. volatile关键字本身就包含了禁止指令重排序的语义。
    2. synchronized则是由“一个变量在**同一个时刻**，**只允许一条线程**对其进行lock操作”这条规则获得的，这个规则决定了持有**同一个锁**的两个同步块，**只能串行进入**。
3. synchronized能满足**原子性，可见性，有序性**三种特性，但是有时候**性能影响**很大。

#### 12.2.6 先行发生原则

1. 先行发生原则：Java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，其实就是发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息，调用了方法，等。
2. 先行发生原则，是判断**数据是否存在竞争**，**线程是否安全**的主要依据。
3. 下面是Java内存模型自带的**先行发生关系**，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。
    >如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来，那么它们就**没有顺序性保障**，虚拟机可以对它们进行随意的重排序。
    1. **程序次序规则（Program Order Rule）**：
    2. **管程锁定规则（Monitor Lock Rule）**：
    3. **volatile变量规则（Volatile Variable Rule）**：
    4. **线程启动规则（Thread Start Rule）**：
    6. **线程终止规则（Thread Termination Rule）**：
    7. **线程中断规则（Thread Interruption Rule）**：
    8. **对象终结规则（Finalizer Rule）**：
    9. **传递性（Transitivity）**：
    
### 12.3 Java与线程



#### 12.3.1 线程的实现



##### 12.3.1.1 使用内核线程实现



##### 12.3.1.2 使用用户线程实现



##### 12.3.1.3 混合实现



##### 12.3.1.4 Java线程的实现



#### 12.3.2 Java线程调度



#### 12.3.3 状态转换



## 参考资料

>1. [jvm主内存与工作内存](https://blog.csdn.net/zxh476771756/article/details/78685581)
>
>2. [你应该知道的 volatile 关键字](https://crossoverjie.top/JCSprout/#/jvm/volatile)
>
>
>
>
>